#include "../inc/SEMath.h"

const SEVec3i SEMath::UNIT_X_3i = SEVec3<int>(1,0,0)
            , SEMath::UNIT_Y_3i = SEVec3<int>(0,1,0)
            , SEMath::UNIT_Z_3i = SEVec3<int>(0,0,1);

const SEVec3f SEMath::UNIT_X_3f = SEVec3<float>(1,0,0)
            , SEMath::UNIT_Y_3f = SEVec3<float>(0,1,0)
            , SEMath::UNIT_Z_3f = SEVec3<float>(0,0,1);
            
const SEVec3d SEMath::UNIT_X_3d = SEVec3<double>(1,0,0)
            , SEMath::UNIT_Y_3d = SEVec3<double>(0,1,0)
            , SEMath::UNIT_Z_3d = SEVec3<double>(0,0,1);
    
const SEVec4i SEMath::UNIT_X_4i = SEVec4<int>(1,0,0,0)
            , SEMath::UNIT_Y_4i = SEVec4<int>(0,1,0,0)
            , SEMath::UNIT_Z_4i = SEVec4<int>(0,0,1,0)
            , SEMath::UNIT_W_4i = SEVec4<int>(0,0,0,1);
            
const SEVec4f SEMath::UNIT_X_4f = SEVec4<float>(1,0,0,0)
            , SEMath::UNIT_Y_4f = SEVec4<float>(0,1,0,0)
            , SEMath::UNIT_Z_4f = SEVec4<float>(0,0,1,0)
            , SEMath::UNIT_W_4f = SEVec4<float>(0,0,0,1);
            
const SEVec4d SEMath::UNIT_X_4d = SEVec4<double>(1,0,0,0)
            , SEMath::UNIT_Y_4d = SEVec4<double>(0,1,0,0)
            , SEMath::UNIT_Z_4d = SEVec4<double>(0,0,1,0)
            , SEMath::UNIT_W_4d = SEVec4<double>(0,0,0,1);

const SEQuaternionf SEMath::DEFAULT_ORIENTATIONf = SEQuaternion<float>(0,0,0,1);
const SEQuaterniond SEMath::DEFAULT_ORIENTATIONd = SEQuaternion<double>(0,0,0,1);

const SEMat3i SEMath::IDENTITY_3i = SEMat3<int>(1,0,0,
                                                0,1,0,
                                                0,0,1);
const SEMat3f SEMath::IDENTITY_3f = SEMat3<float>(1,0,0,
                                                  0,1,0,
                                                  0,0,1);
const SEMat3d SEMath::IDENTITY_3d = SEMat3<double>(1,0,0,
                                                   0,1,0,
                                                   0,0,1);
    
const SEMat4i SEMath::IDENTITY_4i = SEMat4<int>(1,0,0,0,
                                                0,1,0,0,
                                                0,0,1,0,
                                                0,0,0,1);
const SEMat4f SEMath::IDENTITY_4f = SEMat4<float>(1,0,0,0,
                                                  0,1,0,0,
                                                  0,0,1,0,
                                                  0,0,0,1);
const SEMat4d SEMath::IDENTITY_4d = SEMat4<double>(1,0,0,0,
                                                   0,1,0,0,
                                                   0,0,1,0,
                                                   0,0,0,1);
    
template <class T>
void SEVec3<T>::rotateInX( T angle )
{
     T rad = toRadians(angle);
     T tempY = y;
     T tempZ = z;
     
     y = tempY * cos(rad) - tempZ * sin(rad);
     z = tempY * sin(rad) + tempZ * cos(rad);
}

template <class T>
void SEVec3<T>::rotateInY( T angle )
{
     T rad = toRadians(angle);
     T tempX = x;
     T tempZ = z;
     
     z = tempZ * cos(rad) - tempX * sin(rad);
     x = tempZ * sin(rad) + tempX * cos(rad);
}

template <class T>
void SEVec3<T>::rotateInZ( T angle )
{
     T rad = toRadians(angle);
     T tempX = x;
     T tempY = y;
     
     x = tempX * cos(rad) - tempY * sin(rad);
     y = tempX * sin(rad) + tempY * cos(rad);
}

template <class T>
void SEVec3<T>::rotateInAxis( T angle, SEVec3<T> axis )
{
     T  rad   = toRadians(angle)
        , l   = axis.dot(axis)
        , u   = axis.x
        , v   = axis.y
        , w   = axis.z
        , u2  = u*u
        , v2  = v*v
        , w2  = w*w;
     
     T  inputMatrix[3][1] = { { this->x }, { this->y }, { this->z } };
     
     T  rotationMatrix[3][3] = { { (u2 + (v2 + w2) * cos(rad)) / l                       , (u * v * (1 - cos(rad)) - w * sqrt(l) * sin(rad)) / l , (u * w * (1 - cos(rad)) + v * sqrt(l) * sin(rad)) / l },
                                 { (u * v * (1 - cos(rad)) + w * sqrt(l) * sin(rad)) / l , (v2 + (u2 + w2) * cos(rad)) / l                       , (v * w * (1 - cos(rad)) - u * sqrt(l) * sin(rad)) / l },
                                 { (u * w * (1 - cos(rad)) - v * sqrt(l) * sin(rad)) / l , (v * w * (1 - cos(rad)) + u * sqrt(l) * sin(rad)) / l , (w2 + (u2 + v2) * cos(rad)) / l                       } };
     
     T  outputMatrix[3][1];
     
     for(int i = 0; i < 3; i++ )
        for(int j = 0; j < 1; j++)
        {
            outputMatrix[i][j] = 0;
            for(int k = 0; k < 3; k++)
                outputMatrix[i][j] += rotationMatrix[i][k] * inputMatrix[k][j];
        }
     
     this->x = outputMatrix[0][0];
     this->y = outputMatrix[1][0];
     this->z = outputMatrix[2][0];
}

template <class T>
inline SEQuaternion<T> &SEQuaternion<T>::vec(const SEMat4<T> &m)
{
  (*this)=m.toQuaternion();
	
	return(*this);
}

template <class T>
inline SEQuaternion<T> &SEQuaternion<T>::operator *=(const SEQuaternion<T> &q)
{
     T tx = q.w*x + q.x*w + q.y*z - q.z*y
     , ty = q.w*y + q.y*w + q.z*x - q.x*z
     , tz = q.w*z + q.z*w + q.x*y - q.y*x
     , tw = q.w*w - q.x*x - q.y*y - q.z*z;
     
     x=tx; y=ty; z=tz; w=tw;
     
     return(*this);
} 

template <class T>
inline SEMat4<T> &SEQuaternion<T>::toMatrix()
{
  T xx      = x * x
  , xy      = x * y
  , xz      = x * z
  , xw      = x * w

  , yy      = y * y
  , yz      = y * z
  , yw      = y * w

  , zz      = z * z
  , zw      = z * w;

  SEMat4<T> r;
  
  r.m00 = 1 - 2 * ( yy + zz );
  r.m01 =     2 * ( xy - zw );
  r.m02 =     2 * ( xz + yw );

  r.m10 =     2 * ( xy + zw );
  r.m11 = 1 - 2 * ( xx + zz );
  r.m12 =     2 * ( yz - xw );

  r.m20 =     2 * ( xz - yw );
  r.m21 =     2 * ( yz + xw );
  r.m22 = 1 - 2 * ( xx + yy );

  r.m03 = r.m13 = r.m23 = r.m30 = r.m31 = r.m32 = 0;
  r.m33 = 1;
  
  return (r);
}

template <class T>
inline SEMat3<T> &SEMat3<T>::operator *=(const SEMat3<T> &n)
{
  SEMat3<T> tmp;
  
  tmp[0] = m[0]*n[0] + m[1]*n[3] + m[2]*n[6];
  tmp[1] = m[0]*n[1] + m[1]*n[4] + m[2]*n[7];
  tmp[2] = m[0]*n[2] + m[1]*n[5] + m[2]*n[8];
  tmp[3] = m[3]*n[0] + m[4]*n[3] + m[5]*n[6];
  tmp[4] = m[3]*n[1] + m[4]*n[4] + m[5]*n[7];
  tmp[5] = m[3]*n[2] + m[4]*n[5] + m[5]*n[8];
  tmp[6] = m[6]*n[0] + m[7]*n[3] + m[8]*n[6];
  tmp[7] = m[6]*n[1] + m[7]*n[4] + m[8]*n[7];
  tmp[8] = m[6]*n[2] + m[7]*n[5] + m[8]*n[8];
  
  return(tmp);
}


template <class T>
inline SEMat3<T> &SEMat3<T>::transpose()
{
  m01^=m10^=m01^=m10; m02^=m20^=m02^=m20;
  m12^=m21^=m12^=m21;
  
  return(*this);
}

template <class T>
inline SEMat3<T> &SEMat3<T>::transpose(const SEMat3<T> &m)
{
  m00=m.m00; m01=m.m10; m02=m.m20;
  m10=m.m01; m11=m.m11; m12=m.m21;
  m20=m.m02; m21=m.m12; m22=m.m22;
  
  return(*this);
}

template <class T>
inline SEMat3<T> &SEMat3<T>::set(const T &n00, const T &n01, const T &n02, const T &n10, const T &n11, const T &n12, const T &n20, const T &n21, const T &n22)
{
  m00=n00; m01=n01; m02=n02;
  m10=n10; m11=n11; m12=n12;
  m20=n20; m21=n21; m22=n22;
  
  return(*this);
}

template <class T>
inline SEMat4<T> &SEMat4<T>::operator *=(const SEMat4<T> &n)
{
  SEMat4<T> tmp;
  
  tmp[0]  = m[0]*n[0]  + m[1]*n[4]  + m[2]*n[8]   + m[3]*n[12];
  tmp[1]  = m[0]*n[1]  + m[1]*n[5]  + m[2]*n[9]   + m[3]*n[13];
  tmp[2]  = m[0]*n[2]  + m[1]*n[6]  + m[2]*n[10]  + m[3]*n[14];
  tmp[3]  = m[0]*n[3]  + m[1]*n[7]  + m[2]*n[11]  + m[3]*n[15];
  tmp[4]  = m[4]*n[0]  + m[5]*n[4]  + m[6]*n[8]   + m[7]*n[12];
  tmp[5]  = m[4]*n[1]  + m[5]*n[5]  + m[6]*n[9]   + m[7]*n[13];
  tmp[6]  = m[4]*n[2]  + m[5]*n[6]  + m[6]*n[10]  + m[7]*n[14];
  tmp[7]  = m[4]*n[3]  + m[5]*n[7]  + m[6]*n[11]  + m[7]*n[15];
  tmp[8]  = m[8]*n[0]  + m[9]*n[4]  + m[10]*n[8]  + m[11]*n[12];
  tmp[9]  = m[8]*n[1]  + m[9]*n[5]  + m[10]*n[9]  + m[11]*n[13];
  tmp[10] = m[8]*n[2]  + m[9]*n[6]  + m[10]*n[10] + m[11]*n[14];
  tmp[11] = m[8]*n[3]  + m[9]*n[7]  + m[10]*n[11] + m[11]*n[15];
  tmp[12] = m[12]*n[0] + m[13]*n[4] + m[14]*n[8]  + m[15]*n[12];
  tmp[13] = m[12]*n[1] + m[13]*n[5] + m[14]*n[9]  + m[15]*n[13];
  tmp[14] = m[12]*n[2] + m[13]*n[6] + m[14]*n[10] + m[15]*n[14];
  tmp[15] = m[12]*n[3] + m[13]*n[7] + m[14]*n[11] + m[15]*n[15];
  
  return(tmp);
}

template <class T>
inline SEMat4<T> &SEMat4<T>::transpose()
{
  m01^=m10^=m01^=m10; m02^=m20^=m02^=m20; m03^=m30^=m03^=m30;
  m12^=m21^=m12^=m21; m13^=m31^=m13^=m31;
  m23^=m32^=m23^=m32;
  
  return(*this);
}

template <class T>
inline SEMat4<T> &SEMat4<T>::transpose(const SEMat4<T> &m)
{
  m00=m.m00; m01=m.m10; m02=m.m20; m03=m.m30;
  m10=m.m01; m11=m.m11; m12=m.m21; m13=m.m31;
  m20=m.m02; m21=m.m12; m22=m.m22; m23=m.m32;
  m30=m.m03; m31=m.m13; m32=m.m23; m33=m.m33;
  
  return(*this);
}

template <class T>
inline SEMat4<T> &SEMat4<T>::set(const T &n00, const T &n01, const T &n02, const T &n03, const T &n10, const T &n11, const T &n12, const T &n13, const T &n20, const T &n21, const T &n22, const T &n23, const T &n30, const T &n31, const T &n32, const T &n33)
{
  m00=n00; m01=n01; m02=n02; m03=n03;
  m10=n10; m11=n11; m12=n12; m13=n13;
  m20=n20; m21=n21; m22=n22; m23=n23;
  m30=n30; m31=n31; m32=n32; m33=n33;
  
  return(*this);
}

template <class T>
inline SEQuaternion<T> &SEMat4<T>::toQuaternion() const
{
  SEQuaternion<T> q;
  
  T tr = trace();
  
  if( tr > 0 ) {
    T s = 0.5 / (T)sqrt(tr + 1);
    q.w = 0.25 / s;
    q.x = (m21 - m12) * s;
    q.y = (m02 - m20) * s;
    q.z = (m10 - m01) * s;
  } else {
    if (m00 > m11 && m00 > m22) {
      T s = 2 * (T)sqrt(1 + m00 - m11 - m22);
      q.w = (m21 - m12) / s;
      q.x = 0.25 * s;
      q.y = (m01 + m10) / s;
      q.z = (m02 + m20) / s;
    } else if (m11 > m22) {
      T s = 2 * (T)sqrt(1 + m11 - m00 - m22);
      q.w = (m02 - m20) / s;
      q.x = (m01 + m10) / s;
      q.y = 0.25 * s;
      q.z = (m12 + m21) / s;
    } else {
      T s = 2 * (T)sqrt(1 + m22 - m00 - m11);
      q.w = (m10 - m01) / s;
      q.x = (m02 + m20) / s;
      q.y = (m12 + m21) / s;
      q.z = 0.25 * s;
    }
  }
  
  return (q);
}

